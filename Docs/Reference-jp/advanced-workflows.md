# SuperClaude 高度なワークフローコレクション

**ステータス**: ✅ **ステータス: 最新** - 洗練されたプロジェクト向けの複雑なコマンドシーケンスとコンテキストの組み合わせ。

**高度な使用ガイド**: 複数のコマンド、エージェント、およびClaude Codeの会話内での慎重なコンテキスト管理を使用する複雑なプロジェクトのパターン。

## 概要と使用ガイド

**目的**: コマンドの慎重な順序付けとコンテキスト管理を必要とする、複雑でマルチステップのプロジェクト向けの高度なSuperClaudeパターン。

**重要**: これらは会話のパターンであり、実行されるワークフローではありません。すべての作業は、提供されたコンテキストに基づいてClaude Code内で行われます。

**主要概念**:
- 会話内でのコマンドシーケンス
- 複数のエージェントによるコンテキストの階層化
- 段階的な洗練アプローチ
- プロジェクトフェーズ管理（自動化ではなく手動）

## マルチコンテキストプロジェクトパターン

### フルスタック開発シーケンス

```bash
# 複数のコンテキストを使用したeコマースプラットフォーム
# ステップ1: アーキテクチャコンテキスト
@agent-system-architect "eコマースアーキテクチャを設計する"

# ステップ2: セキュリティ要件
@agent-security "支払いのためのセキュリティ要件を定義する"

# ステップ3: バックエンド実装
/sc:implement "認証と支払い処理を備えたAPI"
# Claudeは前のステップから蓄積されたコンテキストを使用する

# ステップ4: フロントエンド実装
@agent-frontend-architect "レスポンシブUIを設計する"
/sc:implement "TypeScriptを使用したReactフロントエンド"

# ステップ5: レビュー
/sc:analyze . --focus quality

# 注意: 各ステップは会話内でコンテキストを構築します
# 実際の調整や並列実行は行われません
```

### 問題解決ワークフロー

```bash
# 複雑なトラブルシューティングアプローチ
# ステップ1: 問題の理解
/sc:troubleshoot "アプリケーションのパフォーマンス問題"

# ステップ2: 専門家による分析
@agent-performance-engineer "潜在的なボトルネックを分析する"
@agent-backend-architect "問題のアーキテクチャをレビューする"

# ステップ3: 解決策の設計
/sc:design "パフォーマンス改善計画"

# ステップ4: 実装
/sc:implement "パフォーマンスの最適化"

# コンテキストは蓄積されますが、実行はされません
```

## 複雑なプロジェクトのフェーズ

### プロジェクト初期化パターン

```bash
# 新規プロジェクトの開始
# 発見フェーズ
/sc:brainstorm "プロジェクトのコンセプト"
# Claudeが要件を探る

# 計画フェーズ
/sc:design "システムアーキテクチャ"
@agent-system-architect "レビューと洗練"

# ドキュメンテーション
/sc:document --type architecture
/sc:save "project-plan"
# 記録用に要約を作成します（永続的なストレージではありません）
```

### インクリメンタル開発パターン

```bash
# 段階的に機能を構築する
# 機能1: 認証
/sc:implement "ユーザー認証"
/sc:test --focus security
/sc:document --type api

# 機能2: ユーザープロファイル（認証コンテキスト上に構築）
/sc:implement "ユーザープロファイル管理"
/sc:test --focus functionality

# 機能3: 管理ダッシュボード（以前のコンテキストを使用）
/sc:implement "管理ダッシュボード"
@agent-frontend-architect "一貫性を確保する"

# 各機能は会話のコンテキスト上に構築されます
```

### 移行プロジェクトパターン

```bash
# レガシーシステムの移行
# フェーズ1: 分析
/sc:load legacy-system/
/sc:analyze . --focus architecture --verbose
# Claudeが理解を深める

# フェーズ2: 計画
@agent-system-architect "移行戦略を設計する"
/sc:workflow "移行計画を作成する"

# フェーズ3: 実装
/sc:implement "互換性レイヤー"
/sc:implement "新しいシステムコンポーネント"

# フェーズ4: 検証
/sc:test --focus compatibility
/sc:document --type migration

# 自動化されたワークフローではなく、手動のフェーズ
```

## エンタープライズスケールパターン

### 大規模コードベース分析

```bash
# 大規模プロジェクトの体系的な分析
# 概要
/sc:analyze . --overview
# 高レベルの理解を得る

# モジュールごとの集中分析
/sc:analyze auth-module/ --focus security
/sc:analyze api-module/ --focus quality
/sc:analyze frontend/ --focus performance

# 統合
@agent-system-architect "調査結果を統合する"
/sc:workflow "改善の推奨事項"

# 注意: 並列ではなく、逐次分析
```

### マルチテクノロジープロジェクト

```bash
# 多様な技術スタックを持つプロジェクト
# バックエンド (Python)
@agent-python-expert "FastAPIバックエンドを実装する"
/sc:implement "非同期サポート付きのPython API"

# フロントエンド (React)
@agent-frontend-architect "Reactフロントエンドを実装する"
/sc:implement "TypeScript Reactアプリケーション"

# モバイル (React Native)
/sc:implement "React Nativeモバイルアプリ"

# インフラストラクチャ
@agent-devops-architect "デプロイメントを設計する"
/sc:implement "Docker設定"

# 各技術は順次対処されます
```

## 品質保証ワークフロー

### 包括的レビューパターン

```bash
# 多角的なコードレビュー
# 品質レビュー
/sc:analyze . --focus quality
@agent-quality-engineer "改善点を特定する"

# セキュリティレビュー
/sc:analyze . --focus security
@agent-security "脆弱性をチェックする"

# アーキテクチャレビュー
@agent-system-architect "設計を評価する"

# パフォーマンスレビュー
@agent-performance-engineer "最適化を提案する"

# 統合された改善
/sc:improve . --fix

# 並列分析ではなく、逐次レビュー
```

### テスト戦略パターン

```bash
# 包括的なテストアプローチ
# テスト計画
/sc:design "テスト戦略"

# ユニットテスト
/sc:test --type unit
# Claudeがユニットテストコードを生成する

# 統合テスト
/sc:test --type integration
# Claudeが統合テストコードを生成する

# E2Eテスト
/sc:test --type e2e
# ClaudeがE2Eテストシナリオを提案する

# ドキュメンテーション
/sc:document --type testing

# 実行ではなく、テストコードの生成
```

## セッション管理パターン

### 長期プロジェクトセッション

```bash
# 長い会話でのコンテキスト管理
# コンテキストから始める
/sc:load project/

# 段階的に作業を進める
/sc:implement "機能A"
/sc:implement "機能B"
# コンテキストが蓄積される

# チェックポイントを作成
/sc:save "session-checkpoint"
# メモ用に要約を作成

# 作業を続ける
/sc:implement "機能C"

# 最終要約
/sc:reflect
# 会話の進行状況をレビューする
```

### コンテキストリフレッシュパターン

```bash
# 会話が長くなりすぎたとき
# 現在の状態を保存
/sc:save "work-complete"
# 次の会話のために出力をコピーする

# 新しい会話で:
/sc:load project/
"前の作業: [要約を貼り付け]"
# 手動でコンテキストを復元

# 作業を続ける
/sc:implement "次の機能"
```

## 重要な明確化

### これらのワークフローが「そうである」もの

- ✅ **会話パターン**: 単一のClaude会話内のシーケンス
- ✅ **コンテキスト構築**: 理解の段階的な蓄積
- ✅ **コマンドシーケンス**: より良い結果を得るためのコマンドの順序付け
- ✅ **手動フェーズ**: ユーザー制御によるプロジェクトの進行

### これらのワークフローが「そうではない」もの

- ❌ **自動化されたワークフロー**: 自動実行やオーケストレーションはなし
- ❌ **並列処理**: すべてが逐次的
- ❌ **永続的セッション**: 会話間でコンテキストは失われる
- ❌ **パフォーマンス最適化**: 最適化するために実行されるコードはない

## ベストプラクティス

### 会話管理

1. **関連作業をまとめる**: 関連タスクを複数の会話に分割しない
2. **段階的にコンテキストを構築する**: 大まかにはじめて、徐々に焦点を絞る
3. **重要な決定を文書化する**: 重要な点には`/sc:save`を使用する
4. **会話の長さを管理する**: 長すぎる場合は新しい会話を始める

### コマンドシーケンシング

1. **論理的な順序**: 分析 → 設計 → 実装 → テスト
2. **コンテキストの蓄積**: 後のコマンドは前のコンテキストから利益を得る
3. **適切な深さ**: タスクの複雑さに分析の深さを合わせる
4. **明確なスコープ**: コマンドを特定の領域に集中させる

### エージェントの使用法

1. **戦略的なアクティベーション**: 特定の専門知識のためにエージェントを使用する
2. **過負荷を避ける**: 多すぎるエージェントは焦点を薄める可能性がある
3. **手動制御**: 正確な制御のために`@agent-`を使用する
4. **コンテキストの階層化**: 論理的な順序でエージェントを追加する

## まとめ

SuperClaudeの高度なワークフローは、単一のClaude Codeセッション内で段階的にコンテキストを構築する洗練された会話パターンです。これらは、慎重なコマンドシーケンシングとコンテキスト管理を通じてより良い出力を生成するのに役立ちますが、実際のワークフロー実行、並列処理、または自動化は一切含みません。成功は、Claudeの会話スコープ内で効果的にコンテキストを階層化する方法を理解することから生まれます。
